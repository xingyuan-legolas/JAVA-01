学习笔记

1. 在资源有限的情况下，暂停时间和吞吐需要权衡。并发类回收器需要额外的线程势必与业务线程争抢核心，造成业务处理总的吞吐下降

2. 如果核数很富裕，业务处理只需要一部分 CPU 资源，那么使用 CMS、G1 等并发类回收器可以兼顾应用的吞吐和延迟，比如 GCLogAnalysis 程序中业务处理是单线程的，因此多核机器上 CMS、G1 由于老年代回收暂停时间更短并且并发回收时不会影响业务处理，会比并行回收器有更高的吞吐

3. 如果核数紧张且内存有限的情况下，对于离线处理等注重吞吐的场景通常使用并行回收器会更高效；对于延迟敏感的应用，如果敏感阈值很高，由于堆内存很少，即使发生 Full GC，并行回收器也不会有太长的暂停，如果延迟敏感的阈值很低，那么只能牺牲应用单点的吞吐使用并发类回收器

4. 对于高分配速率且对象寿命很短的应用，增大新生代可以降低新生代的回收频率，同时可以避免短命对象提前晋升到老年代从而降低老年代回收频率，因此可以显著提升吞吐，当然前提是应用同时能够容忍大新生代回收带来的延迟的增加，否则只能维持小一点的新生代从而牺牲吞吐，可以看到 G1 在高分配速率且期望暂停时间设置较小的场景下会将新生代的分区数调整到很少

5. 老年代发生频繁回收要么可能是内存泄漏导致老年代累积，要么可能是应用的负载增大导致分配速率增高，本来短命的新生代对象提前晋升到老年代。从某个角度看对于整个系统没有合理保护的应用，稍大一点的老年代甚至是一种缓冲，防止并发类回收器因为非预期的负载增大劣化到 Full GC

6. 对于并发类回收器，由于并发阶段中对象依然可以分配和晋升，为了避免发生 Full GC，回收的速度必须超过晋升的速度，这就需要增加并发回收线程数量从而增大回收速度，或者将触发老年代回收的阈值降低从而增加了到 Full GC 发生前的回收容忍时间

7. CMS 由于只清除不压缩，因此老年代的碎片会积累，从而之后发生 Full GC 的风险不断增加，此外对于大堆内存的应用，回收时间无法控制，而 G1 将堆内存分区，对于老年代只进行局部的标记复制，因此对于堆内存大且对延迟敏感的应用，G1 是首选回收器

8. 对于频繁分配短命大对象的场景，G1 需要设置分区大小，以避免直接分配到老年代中且占据连续的分区，导致混合回收频繁，甚至因为找不到连续的分区进一步劣化到 Full GC
